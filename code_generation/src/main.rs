use jta_display_wall_adapter::{MessageFromWebControl, MessageToWebControl};
use rust_to_ts_types::TypescriptSerializable;
use std::{collections::HashSet, fs, path::PathBuf};

fn main() {
    // TODO restructure ALL code, so that this can be compile time dependency of the main crate
    // For this, you would need to extract ALL types that are serealized into another types crate

    // generate output string
    println!("Generating ts interface");
    let mut collector = Vec::new();
    collector.append(&mut MessageFromWebControl::all_types_output());
    collector.append(&mut MessageToWebControl::all_types_output());

    let mut out_vec = collector
        .into_iter()
        .collect::<HashSet<_>>()
        .into_iter()
        .collect::<Vec<_>>();

    out_vec.sort();

    let out_str = out_vec.into_iter().fold(String::new(), |a, b| a + &b);

    // write output string
    println!("Exporting ts interface");
    let out_dir = "./../web_client/src/generated/";
    let dest = PathBuf::from(out_dir).join("interface.ts");
    fs::write(
        &dest,
        format!("{}\n{}", "// Generated by /code_generation", out_str).as_bytes(),
    )
    .unwrap();
}
