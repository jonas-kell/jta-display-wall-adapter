use crate::{
    args::Args,
    bitmap::png_to_bmp_bytes,
    instructions::{InstructionFromTimingClient, InstructionToTimingClient},
};

const NUMBER_OF_HEADER_BYTES: usize = 17;
// https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d.pdf -> page 37
// 1 Byte RecordTypeEnum -> value must be 0
// 4 Bytes RootId
// 4 Bytes HeaderId
// 4 Bytes MajorVersion -> value must be 1
// 4 Bytes MinorVersion -> value must be 0

/// Decode the message custom action
pub fn decode_single_nrbf(
    args: &Args,
    packet: &[u8],
) -> Result<InstructionFromTimingClient, String> {
    let header_bytes = &packet[0..NUMBER_OF_HEADER_BYTES];
    let rest_bytes = &packet[NUMBER_OF_HEADER_BYTES..];

    let record_type = header_bytes[0];
    let root_id = i32_from_bytes(&header_bytes[1..5]);
    let header_id = i32_from_bytes(&header_bytes[5..9]);
    let major_version = i32_from_bytes(&header_bytes[9..13]);
    let minor_version = i32_from_bytes(&header_bytes[13..17]);

    if record_type != 0x00 {
        return Err("RecordTypeEnum in Header must be 0".into());
    }
    if major_version != 1 {
        return Err("Major Version not 1".into());
    }
    if minor_version != 0 {
        return Err("Minor Version not 0".into());
    }

    trace!("Header: root_id:{} header_id:{}", root_id, header_id);
    if args.hexdump_incoming_communication {
        hex_log_bytes(header_bytes);
    }

    if args.hexdump_incoming_communication {
        debug!("No command could be parsed from the following:");
        text_log_bytes(rest_bytes);
    }

    Err("No matching command could be parsed".into())
}

fn i32_from_bytes(bytes: &[u8]) -> i32 {
    return i32::from_le_bytes(bytes.try_into().unwrap_or([0x00, 0x00, 0x00, 0x00]));
}

pub fn hex_log_bytes(buf: &[u8]) {
    let hex_repr = buf
        .iter()
        .map(|b| format!("{:02X}", b))
        .collect::<Vec<_>>()
        .join(" ");

    trace!(
        "({} bytes) Hex: \n{}",
        buf.len(),
        hex_repr.chars().collect::<String>(),
    );
}

fn text_log_bytes(buf: &[u8]) {
    let decoded: String = String::from_utf8_lossy(buf).to_string();

    let hex_repr = buf
        .iter()
        .map(|b| format!("{:02X}", b))
        .collect::<Vec<_>>()
        .join(" ");

    trace!(
        "({} bytes)\nText: \n{}\nHex: \n{}",
        buf.len(),
        decoded.chars().collect::<String>(),
        hex_repr.chars().collect::<String>(),
    );
}

const HEADER_BYTES_TEMPLATE: [u8; 17] = [
    0x00, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,
];

fn pre_response() -> Vec<u8> {
    let content: [u8; 1596] = [
        0x0C, 0x02, 0x00, 0x00, 0x00, 0x53, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F,
        0x61, 0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6F, 0x6E, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x31, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x31, 0x32, 0x38, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65,
        0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69,
        0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x6E, 0x75, 0x6C, 0x6C, 0x05,
        0x01, 0x00, 0x00, 0x00, 0x2D, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F, 0x61,
        0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x2E, 0x50, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2E, 0x53, 0x65, 0x72, 0x76, 0x65,
        0x72, 0x49, 0x6E, 0x66, 0x6F, 0x02, 0x00, 0x00, 0x00, 0x23, 0x3C, 0x41, 0x70, 0x6C, 0x6C,
        0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3E,
        0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64,
        0x19, 0x3C, 0x43, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x73, 0x3E, 0x6B, 0x5F, 0x5F, 0x42,
        0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x01, 0x03, 0xBA, 0x02,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69,
        0x6F, 0x6E, 0x73, 0x2E, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2E, 0x4C, 0x69, 0x73,
        0x74, 0x60, 0x31, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70,
        0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E,
        0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20,
        0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30,
        0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72,
        0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F,
        0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33,
        0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E,
        0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69,
        0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E,
        0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65,
        0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65,
        0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36,
        0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x02,
        0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x00, 0x09, 0x31, 0x2E, 0x30, 0x2E, 0x30, 0x2E,
        0x31, 0x32, 0x38, 0x09, 0x04, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0xBA, 0x02,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69,
        0x6F, 0x6E, 0x73, 0x2E, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2E, 0x4C, 0x69, 0x73,
        0x74, 0x60, 0x31, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70,
        0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E,
        0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20,
        0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30,
        0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72,
        0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F,
        0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33,
        0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E,
        0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69,
        0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E,
        0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65,
        0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65,
        0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36,
        0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x03,
        0x00, 0x00, 0x00, 0x06, 0x5F, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x05, 0x5F, 0x73, 0x69, 0x7A,
        0x65, 0x08, 0x5F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x03, 0x00, 0x00, 0xCA, 0x01,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B,
        0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20,
        0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
        0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C,
        0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50,
        0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62,
        0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39,
        0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E,
        0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65,
        0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20,
        0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C,
        0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65,
        0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65,
        0x30, 0x38, 0x39, 0x5D, 0x5D, 0x5B, 0x5D, 0x08, 0x08, 0x09, 0x05, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0xC8, 0x01, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D,
        0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65,
        0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C,
        0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E,
        0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B,
        0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35,
        0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73,
        0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x09,
        0x06, 0x00, 0x00, 0x00, 0x0D, 0x03, 0x04, 0x06, 0x00, 0x00, 0x00, 0xC8, 0x01, 0x53, 0x79,
        0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53,
        0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73,
        0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E,
        0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75,
        0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62,
        0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37,
        0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C,
        0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C,
        0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73,
        0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75,
        0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20,
        0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D,
        0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38,
        0x39, 0x5D, 0x5D, 0x02, 0x00, 0x00, 0x00, 0x07, 0x6D, 0x5F, 0x49, 0x74, 0x65, 0x6D, 0x31,
        0x07, 0x6D, 0x5F, 0x49, 0x74, 0x65, 0x6D, 0x32, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x06, 0x07, 0x00, 0x00, 0x00, 0x06, 0x4F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x0B, 0x01, 0x01,
        0x02, 0x02, 0x03, 0x03, 0x00, 0x00,
    ];

    let combined: Vec<u8> = [HEADER_BYTES_TEMPLATE.as_slice(), content.as_slice()].concat();

    combined
}

fn image_response() -> Vec<u8> {
    let start: [u8; 250] = [
        0x0C, 0x02, 0x00, 0x00, 0x00, 0x53, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F,
        0x61, 0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6F, 0x6E, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x31, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x31, 0x32, 0x38, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65,
        0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69,
        0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x6E, 0x75, 0x6C, 0x6C, 0x05,
        0x01, 0x00, 0x00, 0x00, 0x2E, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F, 0x61,
        0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x2E, 0x50, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2E, 0x43, 0x75, 0x72, 0x72, 0x65,
        0x6E, 0x74, 0x56, 0x69, 0x65, 0x77, 0x03, 0x00, 0x00, 0x00, 0x21, 0x3C, 0x49, 0x6D, 0x61,
        0x67, 0x65, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x3E, 0x6B,
        0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x18,
        0x3C, 0x43, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x3E, 0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63,
        0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x1A, 0x3C, 0x54, 0x69, 0x6D, 0x65,
        0x53, 0x74, 0x61, 0x6D, 0x70, 0x3E, 0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E,
        0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x07, 0x00, 0x00, 0x02, 0x08, 0x0D, 0x02, 0x00, 0x00,
        0x00, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    // I assume date param. Must increment to update?
    let modifying = generate_timestamp_bytes();

    let image_data = png_to_bmp_bytes("imagebig.png");

    let data_before_imagea: [u8; 5] = [0x0F, 0x03, 0x00, 0x00, 0x00];

    let image_data_size: [u8; 4] = (image_data.len() as u32).to_le_bytes();

    let data_before_imageb: [u8; 1] = [0x02];

    let data_after_image: [u8; 9] = [0x0B, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x00, 0x00];

    let combined: Vec<u8> = [
        HEADER_BYTES_TEMPLATE.as_slice(),
        start.as_slice(),
        modifying.as_slice(),
        data_before_imagea.as_slice(),
        image_data_size.as_slice(),
        data_before_imageb.as_slice(),
        image_data.as_slice(),
        data_after_image.as_slice(),
    ]
    .concat();

    combined
}

pub fn generate_response_bytes(instruction: InstructionToTimingClient) -> Vec<u8> {
    match instruction {
        InstructionToTimingClient::SendBeforeFrameSetupInstruction => pre_response(),
        InstructionToTimingClient::SendFrame => image_response(),
    }
}

// 2025-11-05T00:02:58Z = D4 84 B5 0F 07 1C DE 88 = 9862351050641867988
// 2025-11-04T23:59:38Z = 47 F4 1B 98 06 1C DE 88 = 9862351048635315271 -> diff=2006552717 =^= 200s

// https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-DTYP/%5bMS-DTYP%5d.pdf
//     The FILETIME structure is a 64-bit value that represents the number of 100-nanosecond intervals that
// have elapsed since January 1, 1601, Coordinated Universal Time (UTC).
// typedef struct _FILETIME {
//  DWORD dwLowDateTime;
//  DWORD dwHighDateTime;
// } FILETIME,
// *PFILETIME,
// *LPFILETIME;

// def counts 100 ns intervals.

// then used one call with more precision to get most likely combination
// -> 2025-11-05 01:06:37.405113302 <-> CD CA 16 F2 0F 1C DE 88

fn generate_timestamp_bytes() -> [u8; 8] {
    let timestamp_number = u64::from_le_bytes(
        [0xCD, 0xCA, 0x16, 0xF2, 0x0F, 0x1C, 0xDE, 0x88]
            .try_into()
            .unwrap(),
    );

    let difference_to_timestamp = chrono::Utc::now().signed_duration_since(
        chrono::DateTime::<chrono::Utc>::from_naive_utc_and_offset(
            chrono::NaiveDateTime::parse_from_str(
                "2025-11-05 01:06:37.405113302",
                "%Y-%m-%d %H:%M:%S.%f",
            )
            .unwrap(),
            chrono::Utc,
        ),
    );

    let count_100ns = (difference_to_timestamp.num_nanoseconds().unwrap() / 100) as u64;

    // Convert to little-endian byte array ([u8; 8])
    let modifying: [u8; 8] = (timestamp_number + count_100ns).to_le_bytes();

    modifying
}
