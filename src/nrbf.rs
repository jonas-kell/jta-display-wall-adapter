use nom::bytes::complete::{tag, take, take_until};
// use nom::combinator::peek as nom_peek;
use nom::error::{Error as NomError, ErrorKind as NomErrorKind};
use nom::sequence::terminated;
use nom::Err::{Error as NomErr, Failure as NomFailure};
use nom::Parser;
use nom::{branch::alt, IResult};

use crate::{
    args::Args,
    bitmap::png_to_bmp_bytes,
    instructions::{InstructionFromTimingClient, InstructionToTimingClient},
};

const NUMBER_OF_HEADER_BYTES: usize = 17;
// https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d.pdf -> page 37
// 1 Byte RecordTypeEnum -> value must be 0
// 4 Bytes RootId
// 4 Bytes HeaderId
// 4 Bytes MajorVersion -> value must be 1
// 4 Bytes MinorVersion -> value must be 0

/// Decode the message custom action
pub fn decode_single_nrbf(
    args: &Args,
    packet: &[u8],
) -> Result<InstructionFromTimingClient, String> {
    let header_bytes = &packet[0..NUMBER_OF_HEADER_BYTES];
    let rest_bytes = &packet[NUMBER_OF_HEADER_BYTES..];

    let record_type = header_bytes[0];
    let root_id = i32_from_bytes(&header_bytes[1..5]);
    let header_id = i32_from_bytes(&header_bytes[5..9]);
    let major_version = i32_from_bytes(&header_bytes[9..13]);
    let minor_version = i32_from_bytes(&header_bytes[13..17]);

    if record_type != 0x00 {
        return Err("RecordTypeEnum in Header must be 0".into());
    }
    if major_version != 1 {
        return Err("Major Version not 1".into());
    }
    if minor_version != 0 {
        return Err("Minor Version not 0".into());
    }

    trace!("Header: root_id:{} header_id:{}", root_id, header_id);
    if args.hexdump_incoming_communication {
        hex_log_bytes(header_bytes);
    }

    match parse_any_known_command(rest_bytes) {
        Err(e) => trace!("Nom parser Error: {}", e.to_string()),
        Ok((_, command)) => return Ok(command),
    }

    if args.hexdump_incoming_communication {
        debug!("No command could be parsed from the following:");
        text_log_bytes(rest_bytes);
    }

    Err("No matching command could be parsed".into())
}

fn i32_from_bytes(bytes: &[u8]) -> i32 {
    return i32::from_le_bytes(bytes.try_into().unwrap_or([0x00, 0x00, 0x00, 0x00]));
}

fn leb128_u32(input: &[u8]) -> IResult<&[u8], u32> {
    let mut result: u32 = 0;
    let mut shift = 0;
    let mut consumed = 0;

    for &byte in input.iter() {
        let value = (byte & 0x7F) as u32;
        result |= value << shift;
        consumed += 1;

        if byte & 0x80 == 0 {
            // MSB not set → last byte
            return Ok((&input[consumed..], result));
        }

        shift += 7;

        // u32 can only be up to 32 bits → max 5 bytes
        if shift >= 32 {
            return Err(NomFailure(NomError::new(
                input,
                nom::error::ErrorKind::TooLarge,
            )));
        }
    }

    Err(nom::Err::Incomplete(nom::Needed::new(1)))
}

fn take_until_and_consume<'a>(pattern: &[u8], input: &'a [u8]) -> IResult<&'a [u8], &'a [u8]> {
    terminated(take_until(pattern), tag(pattern)).parse(input)
}

// fn peek(input: &[u8]) -> IResult<&[u8], &[u8]> {
//     nom_peek(take(4usize)).parse(input)
// }

fn parse_failing_command(input: &[u8]) -> IResult<&[u8], InstructionFromTimingClient> {
    Err(NomErr(NomError::new(input, NomErrorKind::Tag))) // test, this can never be parsed
}

fn parse_client_info_command(input: &[u8]) -> IResult<&[u8], InstructionFromTimingClient> {
    let (input, _) = tag(&b"\x0C\x02\x00\x00\x00\x52\x44\x69\x73\x70\x6C\x61\x79\x42\x6F\x61\x72\x64\x2E\x43\x6F\x6D\x6D\x75\x6E\x69\x63\x61\x74\x69\x6F\x6E\x2C\x20\x56\x65\x72\x73\x69\x6F\x6E\x3D\x31\x2E\x30\x2E\x30\x2E\x31\x37\x2C\x20\x43\x75\x6C\x74\x75\x72\x65\x3D\x6E\x65\x75\x74\x72\x61\x6C\x2C\x20\x50\x75\x62\x6C\x69\x63\x4B\x65\x79\x54\x6F\x6B\x65\x6E\x3D\x6E\x75\x6C\x6C\x05\x01\x00\x00\x00\x2D\x44\x69\x73\x70\x6C\x61\x79\x42\x6F\x61\x72\x64\x2E\x43\x6F\x6D\x6D\x75\x6E\x69\x63\x61\x74\x69\x6F\x6E\x2E\x50\x61\x63\x6B\x65\x74\x73\x2E\x43\x6C\x69\x65\x6E\x74\x49\x6E\x66\x6F\x04\x00\x00\x00\x18\x3C\x43\x68\x61\x6E\x6E\x65\x6C\x3E\x6B\x5F\x5F\x42\x61\x63\x6B\x69\x6E\x67\x46\x69\x65\x6C\x64\x15\x3C\x4E\x61\x6D\x65\x3E\x6B\x5F\x5F\x42\x61\x63\x6B\x69\x6E\x67\x46\x69\x65\x6C\x64\x20\x3C\x41\x70\x70\x6C\x69\x63\x61\x74\x69\x6F\x6E\x4E\x61\x6D\x65\x3E\x6B\x5F\x5F\x42\x61\x63\x6B\x69\x6E\x67\x46\x69\x65\x6C\x64\x23\x3C\x41\x70\x6C\x6C\x69\x63\x61\x74\x69\x6F\x6E\x56\x65\x72\x73\x69\x6F\x6E\x3E\x6B\x5F\x5F\x42\x61\x63\x6B\x69\x6E\x67\x46\x69\x65\x6C\x64\x00\x01\x01\x01\x08\x02\x00\x00\x00\x00\x00\x00\x00\x06\x03\x00\x00\x00\x07\x54\x41\x46\x20\x54\x69\x43\x0A\x0A\x0B\x01\x01\x02\x02\x03\x03\x00\x00"[..])(input)?;

    // TODO non fixed version detection (less strict)

    //0C0200000052446973706C6179426F6172642E436F6D6D756E69636174696F6E2C2056657273696F6E3D312E302E302E31372C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D6E756C6C05010000002D446973706C6179426F6172642E436F6D6D756E69636174696F6E2E5061636B6574732E436C69656E74496E666F04000000183C4368616E6E656C3E6B5F5F4261636B696E674669656C64153C4E616D653E6B5F5F4261636B696E674669656C64203C4170706C69636174696F6E4E616D653E6B5F5F4261636B696E674669656C64233C41706C6C69636174696F6E56657273696F6E3E6B5F5F4261636B696E674669656C6400010101080200000000000000060300000007544146205469430A0A0B0101020203030000

    Ok((input, InstructionFromTimingClient::ClientInfo()))
}

fn parse_text_command(input: &[u8]) -> IResult<&[u8], InstructionFromTimingClient> {
    const FREETEXT: [u8; 45] = [
        0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x00, 0x01, 0x01,
        0x00, 0x08, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x07, 0x00, 0x00,
        0x00, 0x08, 0x46, 0x72, 0x65, 0x65, 0x74, 0x65, 0x78, 0x74, 0x06, 0x08, 0x00, 0x00, 0x00,
    ];

    const TEXT: [u8; 51] = [
        0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x00, 0x01, 0x01,
        0x01, 0x02, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00,
        0x00, 0x06, 0x09, 0x00, 0x00, 0x00, 0x04, 0x54, 0x65, 0x78, 0x74, 0x09, 0x09, 0x00, 0x00,
        0x00, 0x06, 0x0A, 0x00, 0x00, 0x00,
    ];

    let (input, _) = take_until_and_consume(&FREETEXT[..], input)?;
    let (input, _) = take_until_and_consume(&TEXT[..], input)?;
    let (input, text_len) = leb128_u32(input)?;
    debug!("Message Length {}", text_len);
    let (input, text_bytes) = take(text_len)(input)?;

    let text = str::from_utf8(text_bytes)
        .map(|s| s.to_string())
        .map_err(|_| NomFailure(NomError::new(input, NomErrorKind::Alpha)))?;

    // 04010000007F53797374656D2E436F6C6C656374696F6E732E47656E657269632E4C69737460315B5B53797374656D2E4F626A6563742C206D73636F726C69622C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038395D5D03000000065F6974656D73055F73697A65085F76657273696F6E0500000808090200000003000000240000001002000000040000000903000000090400000009050000000A0C0600000052446973706C6179426F6172642E436F6D6D756E69636174696F6E2C2056657273696F6E3D312E302E302E31372C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D6E756C6C05030000002D446973706C6179426F6172642E436F6D6D756E69636174696F6E2E5061636B6574732E4C6F61644C61796F757404000000234C61796F7574426173652B3C4368616E6E656C3E6B5F5F4261636B696E674669656C64244C61796F7574426173652B3C46696C654E616D653E6B5F5F4261636B696E674669656C64204C61796F7574426173652B3C4E616D653E6B5F5F4261636B696E674669656C642A4C61796F7574426173652B3C53656E6443757272656E566965773E6B5F5F4261636B696E674669656C640001010008010600000000000000060700000008467265657465787406080000002B4C61796F75745F66353665353433312D663132632D346261322D626136382D3063666131383339633930650005040000002E446973706C6179426F6172642E436F6D6D756E69636174696F6E2E5061636B6574732E53657450726F706572747905000000183C4368616E6E656C3E6B5F5F4261636B696E674669656C641B3C4C61796F75744E616D653E6B5F5F4261636B696E674669656C641C3C456C656D656E744E616D653E6B5F5F4261636B696E674669656C641D3C50726F70657274794E616D653E6B5F5F4261636B696E674669656C64163C56616C75653E6B5F5F4261636B696E674669656C6400010101020806000000000000000908000000060900000004546578740909000000060A00000014746573747465737474657374746573747465737405050000002D446973706C6179426F6172642E436F6D6D756E69636174696F6E2E5061636B6574732E53686F774C61796F7574050000000B436C6561724F7468657273234C61796F7574426173652B3C4368616E6E656C3E6B5F5F4261636B696E674669656C64244C61796F7574426173652B3C46696C654E616D653E6B5F5F4261636B696E674669656C64204C61796F7574426173652B3C4E616D653E6B5F5F4261636B696E674669656C642A4C61796F7574426173652B3C53656E6443757272656E566965773E6B5F5F4261636B696E674669656C6400000101000108010600000001000000000A0908000000010B0101020203030000

    Ok((input, InstructionFromTimingClient::Freetext(text)))
}

fn parse_any_known_command(input: &[u8]) -> IResult<&[u8], InstructionFromTimingClient> {
    alt((
        |i| parse_failing_command(i),
        |i| parse_client_info_command(i),
        |i| parse_text_command(i),
    ))
    .parse(input)
}

pub fn hex_log_bytes(buf: &[u8]) {
    trace!("({} bytes) Hex: \n{}", buf.len(), get_hex_repr(buf),);
}

// https://hexed.it/
fn get_hex_repr(buf: &[u8]) -> String {
    format!(
        // "\\x{}",
        "{}",
        buf.iter()
            .map(|b| format!("{:02X}", b))
            .collect::<Vec<_>>()
            // .join("\\x")
            .join("")
    )
}

fn text_log_bytes(buf: &[u8]) {
    let decoded: String = String::from_utf8_lossy(buf).to_string();

    trace!(
        "({} bytes)\nText: \n{}\nHex: \n{}",
        buf.len(),
        decoded.chars().collect::<String>(),
        get_hex_repr(buf),
    );
}

const HEADER_BYTES_TEMPLATE: [u8; 17] = [
    0x00, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,
];

fn pre_response() -> Vec<u8> {
    let content: [u8; 1596] = [
        0x0C, 0x02, 0x00, 0x00, 0x00, 0x53, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F,
        0x61, 0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6F, 0x6E, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x31, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x31, 0x32, 0x38, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65,
        0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69,
        0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x6E, 0x75, 0x6C, 0x6C, 0x05,
        0x01, 0x00, 0x00, 0x00, 0x2D, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F, 0x61,
        0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x2E, 0x50, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2E, 0x53, 0x65, 0x72, 0x76, 0x65,
        0x72, 0x49, 0x6E, 0x66, 0x6F, 0x02, 0x00, 0x00, 0x00, 0x23, 0x3C, 0x41, 0x70, 0x6C, 0x6C,
        0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3E,
        0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64,
        0x19, 0x3C, 0x43, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x73, 0x3E, 0x6B, 0x5F, 0x5F, 0x42,
        0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x01, 0x03, 0xBA, 0x02,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69,
        0x6F, 0x6E, 0x73, 0x2E, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2E, 0x4C, 0x69, 0x73,
        0x74, 0x60, 0x31, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70,
        0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E,
        0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20,
        0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30,
        0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72,
        0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F,
        0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33,
        0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E,
        0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69,
        0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E,
        0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65,
        0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65,
        0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36,
        0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x02,
        0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x00, 0x09, 0x31, 0x2E, 0x30, 0x2E, 0x30, 0x2E,
        0x31, 0x32, 0x38, 0x09, 0x04, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0xBA, 0x02,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69,
        0x6F, 0x6E, 0x73, 0x2E, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2E, 0x4C, 0x69, 0x73,
        0x74, 0x60, 0x31, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70,
        0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E,
        0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20,
        0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30,
        0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72,
        0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F,
        0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33,
        0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E,
        0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69,
        0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E,
        0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65,
        0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65,
        0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36,
        0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x03,
        0x00, 0x00, 0x00, 0x06, 0x5F, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x05, 0x5F, 0x73, 0x69, 0x7A,
        0x65, 0x08, 0x5F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x03, 0x00, 0x00, 0xCA, 0x01,
        0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B,
        0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20,
        0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
        0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C,
        0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50,
        0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62,
        0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39,
        0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E,
        0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65,
        0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20,
        0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C,
        0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65,
        0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65,
        0x30, 0x38, 0x39, 0x5D, 0x5D, 0x5B, 0x5D, 0x08, 0x08, 0x09, 0x05, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0xC8, 0x01, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D,
        0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53, 0x79, 0x73, 0x74, 0x65,
        0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C,
        0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E,
        0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B,
        0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35,
        0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C, 0x5B, 0x53, 0x79, 0x73,
        0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6D, 0x73, 0x63,
        0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
        0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72,
        0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C,
        0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37, 0x61,
        0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x5D, 0x09,
        0x06, 0x00, 0x00, 0x00, 0x0D, 0x03, 0x04, 0x06, 0x00, 0x00, 0x00, 0xC8, 0x01, 0x53, 0x79,
        0x73, 0x74, 0x65, 0x6D, 0x2E, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x60, 0x32, 0x5B, 0x5B, 0x53,
        0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x49, 0x6E, 0x74, 0x33, 0x32, 0x2C, 0x20, 0x6D, 0x73,
        0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E,
        0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75,
        0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62,
        0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x62, 0x37, 0x37,
        0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38, 0x39, 0x5D, 0x2C,
        0x5B, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C,
        0x20, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x6C, 0x69, 0x62, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73,
        0x69, 0x6F, 0x6E, 0x3D, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x30, 0x2C, 0x20, 0x43, 0x75,
        0x6C, 0x74, 0x75, 0x72, 0x65, 0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20,
        0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D,
        0x62, 0x37, 0x37, 0x61, 0x35, 0x63, 0x35, 0x36, 0x31, 0x39, 0x33, 0x34, 0x65, 0x30, 0x38,
        0x39, 0x5D, 0x5D, 0x02, 0x00, 0x00, 0x00, 0x07, 0x6D, 0x5F, 0x49, 0x74, 0x65, 0x6D, 0x31,
        0x07, 0x6D, 0x5F, 0x49, 0x74, 0x65, 0x6D, 0x32, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x06, 0x07, 0x00, 0x00, 0x00, 0x06, 0x4F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x0B, 0x01, 0x01,
        0x02, 0x02, 0x03, 0x03, 0x00, 0x00,
    ];

    let combined: Vec<u8> = [HEADER_BYTES_TEMPLATE.as_slice(), content.as_slice()].concat();

    combined
}

fn image_response() -> Vec<u8> {
    let start: [u8; 250] = [
        0x0C, 0x02, 0x00, 0x00, 0x00, 0x53, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F,
        0x61, 0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6F, 0x6E, 0x2C, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x31, 0x2E, 0x30,
        0x2E, 0x30, 0x2E, 0x31, 0x32, 0x38, 0x2C, 0x20, 0x43, 0x75, 0x6C, 0x74, 0x75, 0x72, 0x65,
        0x3D, 0x6E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x2C, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69,
        0x63, 0x4B, 0x65, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x3D, 0x6E, 0x75, 0x6C, 0x6C, 0x05,
        0x01, 0x00, 0x00, 0x00, 0x2E, 0x44, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x42, 0x6F, 0x61,
        0x72, 0x64, 0x2E, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x2E, 0x50, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2E, 0x43, 0x75, 0x72, 0x72, 0x65,
        0x6E, 0x74, 0x56, 0x69, 0x65, 0x77, 0x03, 0x00, 0x00, 0x00, 0x21, 0x3C, 0x49, 0x6D, 0x61,
        0x67, 0x65, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x3E, 0x6B,
        0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x18,
        0x3C, 0x43, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x3E, 0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63,
        0x6B, 0x69, 0x6E, 0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x1A, 0x3C, 0x54, 0x69, 0x6D, 0x65,
        0x53, 0x74, 0x61, 0x6D, 0x70, 0x3E, 0x6B, 0x5F, 0x5F, 0x42, 0x61, 0x63, 0x6B, 0x69, 0x6E,
        0x67, 0x46, 0x69, 0x65, 0x6C, 0x64, 0x07, 0x00, 0x00, 0x02, 0x08, 0x0D, 0x02, 0x00, 0x00,
        0x00, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    // I assume date param. Must increment to update?
    let modifying = generate_timestamp_bytes();

    let image_data = png_to_bmp_bytes("imagebig.png");

    let data_before_imagea: [u8; 5] = [0x0F, 0x03, 0x00, 0x00, 0x00];

    let image_data_size: [u8; 4] = (image_data.len() as u32).to_le_bytes();

    let data_before_imageb: [u8; 1] = [0x02];

    let data_after_image: [u8; 9] = [0x0B, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x00, 0x00];

    let combined: Vec<u8> = [
        HEADER_BYTES_TEMPLATE.as_slice(),
        start.as_slice(),
        modifying.as_slice(),
        data_before_imagea.as_slice(),
        image_data_size.as_slice(),
        data_before_imageb.as_slice(),
        image_data.as_slice(),
        data_after_image.as_slice(),
    ]
    .concat();

    combined
}

pub fn generate_response_bytes(instruction: InstructionToTimingClient) -> Vec<u8> {
    match instruction {
        InstructionToTimingClient::SendBeforeFrameSetupInstruction => pre_response(),
        InstructionToTimingClient::SendFrame => image_response(),
    }
}

// 2025-11-05T00:02:58Z = D4 84 B5 0F 07 1C DE 88 = 9862351050641867988
// 2025-11-04T23:59:38Z = 47 F4 1B 98 06 1C DE 88 = 9862351048635315271 -> diff=2006552717 =^= 200s

// https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-DTYP/%5bMS-DTYP%5d.pdf
//     The FILETIME structure is a 64-bit value that represents the number of 100-nanosecond intervals that
// have elapsed since January 1, 1601, Coordinated Universal Time (UTC).
// typedef struct _FILETIME {
//  DWORD dwLowDateTime;
//  DWORD dwHighDateTime;
// } FILETIME,
// *PFILETIME,
// *LPFILETIME;

// def counts 100 ns intervals.

// then used one call with more precision to get most likely combination
// -> 2025-11-05 01:06:37.405113302 <-> CD CA 16 F2 0F 1C DE 88

fn generate_timestamp_bytes() -> [u8; 8] {
    let timestamp_number = u64::from_le_bytes(
        [0xCD, 0xCA, 0x16, 0xF2, 0x0F, 0x1C, 0xDE, 0x88]
            .try_into()
            .unwrap(),
    );

    let difference_to_timestamp = chrono::Utc::now().signed_duration_since(
        chrono::DateTime::<chrono::Utc>::from_naive_utc_and_offset(
            chrono::NaiveDateTime::parse_from_str(
                "2025-11-05 01:06:37.405113302",
                "%Y-%m-%d %H:%M:%S.%f",
            )
            .unwrap(),
            chrono::Utc,
        ),
    );

    let count_100ns = (difference_to_timestamp.num_nanoseconds().unwrap() / 100) as u64;

    // Convert to little-endian byte array ([u8; 8])
    let modifying: [u8; 8] = (timestamp_number + count_100ns).to_le_bytes();

    modifying
}
